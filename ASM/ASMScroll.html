<!DOCTYPE html>
<html lang="en-US">
<head>
    <link rel="stylesheet" href="../stylesheet.css">
    <script src="http://code.jquery.com/jquery-1.9.1.js"></script>
    <script type="text/javascript" src="../script.js"></script>
    <title>Scroll Project</title>
</head>
<body>
    <div id="background" style="padding-top: 200px; padding-left:100px;"><img src="rnbg.jpg" /></div>
    <div id="textBackground"></div>
    <div id="container">
        <div class="content-div">
        <h1 style="text-align:center;">Scroll Project</h1>
        <p>This project was completed as part of my Embedded Systems course at University of Wisconsin-Superior; the idea was to have a small device that would
            scroll text on a small LCD screen. In this project we use a two line LCD display with a 16 character width to display text characters. The device has the ability 
            to connect to a computer via a micro-USB and text characters can be sent to the device through a terminal application. The device takes the text characters 
            and stores them into an onboard FRAM chip. The device has an on/off switch that controls the standard AAA battery powering the device. Upon powering the 
            device the display and the backlight are activated, the RL-78 microcontroller begins reading the stored text characters from memory, and the characters are 
            sent to the display. The device will scroll multiple lines of text, the speed of which is controlled by sending an integer value at the beginning of the text file sent to the device.  </p>
            <img style="margin-left: 200px;" src="p1.jpg" />
            <img style="margin-left:200px;" src="p2.jpg" />
        <div class="space"></div>
        <h2>Hardware</h2>
        <p>The device uses a Renesas RL-78 microcontroller as the main processing unit. The display is a Newhaven LCD 16x2 unit with backlight functionality and uses 
            I2C communication with the RL-78. We use a Cypress 64Kb FRAM chip as storage, this unit is capable of instant writing and reading cycles along with the 
            advantage that memory is instantly non-volatile, the chip is interface with the RL-78 via I2C. The device is capable of communication with a computer via a SiLabs 
            USB bridge using UART interface. Power is supplied by a standard AAA battery and a Texas Instruments boost DC-DC converter. </p>
        <img src="scroll.png" />
        <div class="space"></div>
        <h2>Software</h2>
        <p>When the device is first powered, either from an off state or from a reset condition, the device will first check the UART pins to determine whether it is connected to 
            a computer. If a connection is detected the device will start a UART segment where it will begin reading information from the USB. This UART process uses a baud rate 
            of 9600 with no parity and 8 bit data. The first character read is considered to be the scrolling speed of the display. The entire string entered by the user is then copied 
            into the FRAM memory until a termination character of '$' is found. Once the termination character is hit, the unit will then begin reading the characters back from memory
             and sending this information to the LCD display. </p>
            <div class="codeBoxN">
                <pre>                    
    </span><span class="sc5">ASEGN</span><span class="sc0">   </span><span class="sc5">RCODE</span><span class="sc4">:</span><span class="sc5">CODE</span><span class="sc4">,</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">       </span><span class="sc1">; vector table</span><span class="sc0">
    </span><span class="sc9">ORG</span><span class="sc0">     </span><span class="sc5">RST_vect</span><span class="sc0">
    </span><span class="sc9">DW</span><span class="sc0">      </span><span class="sc5">RESET</span><span class="sc0">               </span><span class="sc1">; Reset vector</span><span class="sc0">
    </span><span class="sc9">ORG</span><span class="sc0">     </span><span class="sc5">INTIICA0_vect</span><span class="sc0">
    </span><span class="sc9">DW</span><span class="sc0">      </span><span class="sc5">I2C_ISR</span><span class="sc0">             </span><span class="sc1">; I2C vector</span><span class="sc0">
    </span><span class="sc9">ORG</span><span class="sc0">     </span><span class="sc5">INTIT_vect</span><span class="sc0">
    </span><span class="sc9">DW</span><span class="sc0">      </span><span class="sc5">INTIT_ISR</span><span class="sc0">           </span><span class="sc1">; 12-bit interval timer vector</span><span class="sc0">
    </span><span class="sc9">ORG</span><span class="sc0">     </span><span class="sc5">INTST0_vect</span><span class="sc0">
    </span><span class="sc9">DW</span><span class="sc0">      </span><span class="sc5">INTST0_ISR</span><span class="sc0">          </span><span class="sc1">; UART transmit vector</span><span class="sc0">
    </span><span class="sc9">ORG</span><span class="sc0">     </span><span class="sc5">INTSR0_vect</span><span class="sc0">
    </span><span class="sc9">DW</span><span class="sc0">      </span><span class="sc5">INTSR0_ISR</span><span class="sc0">          </span><span class="sc1">; UART receive vector</span><span class="sc0">
    </span><span class="sc9">ORG</span><span class="sc0"> </span><span class="sc2">0xC0</span><span class="sc0">                    </span><span class="sc1">; option byte</span><span class="sc0">
    </span><span class="sc9">DB</span><span class="sc0">  </span><span class="sc2">0x6E</span><span class="sc0">                    </span><span class="sc1">; disable watchdog</span><span class="sc0">
    </span><span class="sc9">DB</span><span class="sc0">  </span><span class="sc2">0x1F</span><span class="sc0">                    </span><span class="sc1">; 1.67V/1.63V LVD off</span><span class="sc0">
    </span><span class="sc9">DB</span><span class="sc0">  </span><span class="sc2">0xAA</span><span class="sc0">                    </span><span class="sc1">; 8 MHz LS mode</span><span class="sc0">
    </span><span class="sc9">DB</span><span class="sc0">  </span><span class="sc2">0x85</span><span class="sc0">                    </span><span class="sc1">; enable on-chip debugging</span><span class="sc0">
        </span><span class="sc5">RSEG</span><span class="sc0">    </span><span class="sc5">CODE</span><span class="sc0">            </span><span class="sc1">; code segment</span><span class="sc0">
</span><span class="sc5">RESET</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc5">movw</span><span class="sc0">    </span><span class="sc8">SP</span><span class="sc4">,</span><span class="sc0"> #</span><span class="sc5">SFE</span><span class="sc4">(</span><span class="sc5">CSTACK</span><span class="sc4">)</span><span class="sc1">; setting up the stack pointer</span><span class="sc0">
    </span><span class="sc1">; clock setup</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc5">HOCODIV</span><span class="sc4">,</span><span class="sc0">    #</span><span class="sc2">0x02</span><span class="sc0">       </span><span class="sc1">; set 8 MHz system clock</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc5">PER0</span><span class="sc4">,</span><span class="sc0">       #</span><span class="sc2">0x90</span><span class="sc0">       </span><span class="sc1">; enable RTC, I2C operation</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc5">OSMC</span><span class="sc4">,</span><span class="sc0">       #</span><span class="sc2">0x90</span><span class="sc0">       </span><span class="sc1">; select LFO as s/system clock</span><span class="sc0">
    </span><span class="sc5">clrw</span><span class="sc0">    </span><span class="sc8">AX</span><span class="sc0">                  </span><span class="sc1">; power-up delay for 65 msec</span><span class="sc0">
</span><span class="sc5">pw_up</span><span class="sc4">:</span><span class="sc0">  
    </span><span class="sc5">br</span><span class="sc0">      </span><span class="sc10">$</span><span class="sc4">+</span><span class="sc2">2</span><span class="sc0">                 </span><span class="sc1">; to debounce the button            </span><span class="sc0">
    </span><span class="sc5">subw</span><span class="sc0">    </span><span class="sc8">AX</span><span class="sc4">,</span><span class="sc0">     #</span><span class="sc2">1</span><span class="sc0">          </span><span class="sc1">; 1 usec delay for CPU</span><span class="sc0">
    </span><span class="sc5">bnz</span><span class="sc0">     </span><span class="sc5">pw_up</span><span class="sc0">               </span><span class="sc1">; clocked at 8 MHz  </span><span class="sc0">
    </span><span class="sc1">; ports setup</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">ADPC</span><span class="sc4">,</span><span class="sc0">   #</span><span class="sc2">0x01</span><span class="sc0">       </span><span class="sc1">; set digital mode on all pins</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">PM1</span><span class="sc4">,</span><span class="sc0">    #</span><span class="sc2">0xF2</span><span class="sc0">       </span><span class="sc1">; configure port for input (p11, p12)</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">PMC1</span><span class="sc4">,</span><span class="sc0">   #</span><span class="sc2">0xE0</span><span class="sc0">       </span><span class="sc1">; set digital mode for P1</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">PM2</span><span class="sc4">,</span><span class="sc0">    #</span><span class="sc2">0xF0</span><span class="sc0">       </span><span class="sc1">; configure port for output</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">PM4</span><span class="sc4">,</span><span class="sc0">    #</span><span class="sc2">0xF9</span><span class="sc0">       </span><span class="sc1">; configure port for output</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">PMC4</span><span class="sc4">,</span><span class="sc0">   #</span><span class="sc2">0xF9</span><span class="sc0">       </span><span class="sc1">; set digital mode for P4</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">P1</span><span class="sc4">,</span><span class="sc0">     #</span><span class="sc2">0x04</span><span class="sc0">       </span><span class="sc1">; init port outputs</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">P2</span><span class="sc4">,</span><span class="sc0">     #</span><span class="sc2">0x00</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">P4</span><span class="sc4">,</span><span class="sc0">     #</span><span class="sc2">0x00</span><span class="sc0">
    </span><span class="sc1">; I2C setup</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">IICWL0</span><span class="sc4">,</span><span class="sc0"> #</span><span class="sc2">31</span><span class="sc0">         </span><span class="sc1">; setup for 120 KHz operation @ 8 MHz</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">IICWH0</span><span class="sc4">,</span><span class="sc0"> #</span><span class="sc2">34</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">SVA0</span><span class="sc4">,</span><span class="sc0">   #</span><span class="sc2">0x7C</span><span class="sc0">       </span><span class="sc1">; own slave address</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">IICF0</span><span class="sc4">,</span><span class="sc0">  #</span><span class="sc2">3</span><span class="sc0">          </span><span class="sc1">; enable START w/out STOP, no reservation</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">IICCTL00</span><span class="sc4">,</span><span class="sc0"> #</span><span class="sc2">0x0C</span><span class="sc0">
    </span><span class="sc5">clr1</span><span class="sc0">    </span><span class="sc5">MK0H.5</span><span class="sc0">              </span><span class="sc1">; enable I2C interrupts</span><span class="sc0">
    </span><span class="sc5">set1</span><span class="sc0">    </span><span class="sc5">IICCTL00.7</span><span class="sc0">          </span><span class="sc1">; enable I2C operation</span><span class="sc0">
    </span><span class="sc5">set1</span><span class="sc0">    </span><span class="sc5">IICCTL00.6</span><span class="sc0">          </span><span class="sc1">; cancel current operation</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">PM6</span><span class="sc4">,</span><span class="sc0">    #</span><span class="sc2">0xFC</span><span class="sc0">       </span><span class="sc1">; configure port pins for output</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">P6</span><span class="sc4">,</span><span class="sc0">     #</span><span class="sc2">0x00</span><span class="sc0">       </span><span class="sc1">; init I2C pins</span><span class="sc0">
    </span><span class="sc5">EI</span><span class="sc0">                          </span><span class="sc1">; enable interrupts globally</span><span class="sc0">
    </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">Init_System</span><span class="sc0">         </span><span class="sc1">; configure LCD display and memory</span><span class="sc0">
    </span><span class="sc5">mov1</span><span class="sc0">    </span><span class="sc5">CY</span><span class="sc4">,</span><span class="sc0"> </span><span class="sc5">P1.1</span><span class="sc0">            </span><span class="sc1">; USB connected?</span><span class="sc0">
    </span><span class="sc5">sknc</span><span class="sc0">    
     </span><span class="sc6">call</span><span class="sc0">   </span><span class="sc5">get_USB</span><span class="sc0">             </span><span class="sc1">; YES - get string from USB </span><span class="sc0">
    </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">init_FRAM_Read</span><span class="sc0">      </span><span class="sc1">; setup for reading from memory</span><span class="sc0">
    
    </span><span class="sc1">; Interval timer setup</span><span class="sc0">
    </span><span class="sc5">movw</span><span class="sc0">    </span><span class="sc5">ITMC</span><span class="sc4">,</span><span class="sc0">   #</span><span class="sc2">0x8FFF</span><span class="sc0">     </span><span class="sc1">; set 270 msec period, int. enable</span><span class="sc0">
    </span><span class="sc5">clr1</span><span class="sc0">    </span><span class="sc5">MK1L.3</span><span class="sc0">              </span><span class="sc1">; enable 12-bit timer interrupt</span><span class="sc0">
    
</pre><div class="caption">
                    Here we see the startup procedure. After we complete the initial setting of the microcontroller, we check whether the USB is connected; if it
                    is, we begin reading from the USB otherwise we read from memory.
                </div>
            </div>
        <p>If no connection is found right after powering the device up, the device will begin reading information from the FRAM memory and sending the information to the LCD 
            display. The scrolling speed is controlled by a wait state which is set using the integer value entered during a USB load. </p>
            <div class="codeBoxN">
                <pre>
                
</span><span class="sc5">init_FRAM_Read</span><span class="sc4">:</span><span class="sc0">
    </span><span class="sc6">bt</span><span class="sc0">      </span><span class="sc5">IICS0.6</span><span class="sc4">,</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc4">-</span><span class="sc2">0</span><span class="sc0">        </span><span class="sc1">; wait for i2c ready</span><span class="sc0">
    </span><span class="sc5">set1</span><span class="sc0">    </span><span class="sc5">IICCTL00.1</span><span class="sc0">          </span><span class="sc1">; generate START condition</span><span class="sc0">
    </span><span class="sc5">set1</span><span class="sc0">    </span><span class="sc5">IICCTL00.2</span><span class="sc0">          </span><span class="sc1">; setup for ACK</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">IICA0</span><span class="sc4">,</span><span class="sc0">  #</span><span class="sc2">0xA0</span><span class="sc0">       </span><span class="sc1">; send I2C address + write</span><span class="sc0">
    </span><span class="sc5">halt</span><span class="sc0">                        </span><span class="sc1">; wait for the end of transfer</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">IICA0</span><span class="sc4">,</span><span class="sc0">  #</span><span class="sc2">0x00</span><span class="sc0">       </span><span class="sc1">; send address MSB</span><span class="sc0">
    </span><span class="sc5">halt</span><span class="sc0">        
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">IICA0</span><span class="sc4">,</span><span class="sc0">  #</span><span class="sc2">0x00</span><span class="sc0">       </span><span class="sc1">; send address LSB</span><span class="sc0">
    </span><span class="sc5">halt</span><span class="sc0">
    </span><span class="sc5">set1</span><span class="sc0">    </span><span class="sc5">IICCTL00.0</span><span class="sc0">          </span><span class="sc1">; generate STOP condition</span><span class="sc0">
        
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">A</span><span class="sc4">,</span><span class="sc0">      #</span><span class="sc2">20</span><span class="sc0">         </span><span class="sc1">; 10 usec delay needed by I2C</span><span class="sc0">
    </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc5">A</span><span class="sc0">                   </span><span class="sc1">; between STOP and START</span><span class="sc0">
    </span><span class="sc5">bnz</span><span class="sc0">     </span><span class="sc10">$</span><span class="sc4">-</span><span class="sc2">1</span><span class="sc0">
    
    </span><span class="sc6">bt</span><span class="sc0">      </span><span class="sc5">IICS0.6</span><span class="sc4">,</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc4">-</span><span class="sc2">0</span><span class="sc0">
    </span><span class="sc5">set1</span><span class="sc0">    </span><span class="sc5">IICCTL00.1</span><span class="sc0">          </span><span class="sc1">; generate START signal</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">IICA0</span><span class="sc4">,</span><span class="sc0">  #</span><span class="sc2">0xA1</span><span class="sc0">       </span><span class="sc1">; send slave address with r/w = 1</span><span class="sc0">
    </span><span class="sc5">halt</span><span class="sc0">                        </span><span class="sc1">; wait for ACK</span><span class="sc0">
    </span><span class="sc5">clr1</span><span class="sc0">    </span><span class="sc5">IICCTL00.2</span><span class="sc0">          </span><span class="sc1">; setup for NACK</span><span class="sc0">
    </span><span class="sc5">set1</span><span class="sc0">    </span><span class="sc5">IICCTL00.5</span><span class="sc0">          </span><span class="sc1">; request next char form FRAM</span><span class="sc0">
    </span><span class="sc5">halt</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">A</span><span class="sc4">,</span><span class="sc0">  </span><span class="sc5">IICA0</span><span class="sc0">           </span><span class="sc1">; get speed</span><span class="sc0">
    </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc5">A</span><span class="sc4">,</span><span class="sc0">      #</span><span class="sc2">0x30</span><span class="sc0">       </span><span class="sc1">; sub 48d from ascii code</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">SPEED</span><span class="sc4">,</span><span class="sc0">  </span><span class="sc5">A</span><span class="sc0">           </span><span class="sc1">; set the speed </span><span class="sc0">
    </span><span class="sc5">set1</span><span class="sc0">    </span><span class="sc5">IICCTL00.0</span><span class="sc0">          </span><span class="sc1">; generate STOP signal</span><span class="sc0">
    
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">A</span><span class="sc4">,</span><span class="sc0">      #</span><span class="sc2">20</span><span class="sc0">         </span><span class="sc1">; 10 usec delay needed by I2C</span><span class="sc0">
    </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc5">A</span><span class="sc0">                   </span><span class="sc1">; between STOP and START</span><span class="sc0">
    </span><span class="sc5">bnz</span><span class="sc0">     </span><span class="sc10">$</span><span class="sc4">-</span><span class="sc2">1</span><span class="sc0"> 
    </span><span class="sc6">ret</span><span class="sc0"> 
    
</pre><div class="caption">Here is the routine for reading from the onboard memory chip.</div>
            </div>
        <p>If the controller does see that a USB cable is connected it will call a routine that will begin reading characters from the USB cable and storing them into memory.
            The devices uses a USB to UART bridge that allows us to use the UART protocol through a USB interface. The signals must be sent with a Serial Communication
            program capabale of producing UART signals. PuTTy is a good program for this, although I also wrote my own Serial Communication program with Java that allows
            for UART communications through USB connections.</p>
            <div class="codeBoxN">
                <pre>                
</span><span class="sc1">;==============UART SETUP======================================</span><span class="sc0">
</span><span class="sc5">init_UART</span><span class="sc4">:</span><span class="sc0">
    </span><span class="sc5">set1</span><span class="sc0">    </span><span class="sc5">PER0.2</span><span class="sc0">              </span><span class="sc1">; enable clock for SAU0</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">SPS0L</span><span class="sc4">,</span><span class="sc0">  #</span><span class="sc2">0x22</span><span class="sc0">       </span><span class="sc1">; set 2 MHz SAU0 clock</span><span class="sc0">
    </span><span class="sc5">movw</span><span class="sc0">    </span><span class="sc8">AX</span><span class="sc4">,</span><span class="sc0">     #</span><span class="sc2">0x0022</span><span class="sc0">     </span><span class="sc1">; set UART mode, CKS00 clock</span><span class="sc0">
    </span><span class="sc5">movw</span><span class="sc0">    </span><span class="sc5">SMR00</span><span class="sc4">,</span><span class="sc0">  </span><span class="sc8">AX</span><span class="sc0">      
    </span><span class="sc5">movw</span><span class="sc0">    </span><span class="sc8">AX</span><span class="sc4">,</span><span class="sc0">     #</span><span class="sc2">0x8197</span><span class="sc0">
    </span><span class="sc5">movw</span><span class="sc0">    </span><span class="sc5">SCR00</span><span class="sc4">,</span><span class="sc0">  </span><span class="sc8">AX</span><span class="sc0">          </span><span class="sc1">; enable TX, 8N1, 8-bit data  </span><span class="sc0">
    </span><span class="sc5">movw</span><span class="sc0">    </span><span class="sc8">AX</span><span class="sc4">,</span><span class="sc0">     #</span><span class="sc2">0xCE00</span><span class="sc0">     </span><span class="sc1">; setup for 9600 baud</span><span class="sc0">
    </span><span class="sc5">movw</span><span class="sc0">    </span><span class="sc5">SDR00</span><span class="sc4">,</span><span class="sc0">  </span><span class="sc8">AX</span><span class="sc0">
    
    </span><span class="sc5">movw</span><span class="sc0">    </span><span class="sc8">AX</span><span class="sc4">,</span><span class="sc0">     #</span><span class="sc2">0x8122</span><span class="sc0">     </span><span class="sc1">; set UART mode, CKS01 clock</span><span class="sc0">
    </span><span class="sc5">movw</span><span class="sc0">    </span><span class="sc5">SMR01</span><span class="sc4">,</span><span class="sc0">  </span><span class="sc8">AX</span><span class="sc0">
    </span><span class="sc5">movw</span><span class="sc0">    </span><span class="sc8">AX</span><span class="sc4">,</span><span class="sc0">     #</span><span class="sc2">0x6197</span><span class="sc0">
    </span><span class="sc5">movw</span><span class="sc0">    </span><span class="sc5">SCR01</span><span class="sc4">,</span><span class="sc0">  </span><span class="sc8">AX</span><span class="sc0">          </span><span class="sc1">; enable RX, 8N1, 8-bit data </span><span class="sc0">
    </span><span class="sc5">movw</span><span class="sc0">    </span><span class="sc8">AX</span><span class="sc4">,</span><span class="sc0">     #</span><span class="sc2">0xCE00</span><span class="sc0">     </span><span class="sc1">; setup for 9600 baud</span><span class="sc0">
    </span><span class="sc5">movw</span><span class="sc0">    </span><span class="sc5">SDR01</span><span class="sc4">,</span><span class="sc0">  </span><span class="sc8">AX</span><span class="sc0">
    
    </span><span class="sc5">movw</span><span class="sc0">    </span><span class="sc8">AX</span><span class="sc4">,</span><span class="sc0">     #</span><span class="sc2">0x401</span><span class="sc0">      </span><span class="sc1">; set output =1</span><span class="sc0">
    </span><span class="sc5">movw</span><span class="sc0">    </span><span class="sc5">SO0</span><span class="sc4">,</span><span class="sc0">    </span><span class="sc8">AX</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">SOE0L</span><span class="sc4">,</span><span class="sc0">  #</span><span class="sc2">1</span><span class="sc0">          </span><span class="sc1">; enable serial output  </span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">SSC0</span><span class="sc4">,</span><span class="sc0">   #</span><span class="sc2">2</span><span class="sc0">          </span><span class="sc1">; enable receive interrupt</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">SS0L</span><span class="sc4">,</span><span class="sc0">   #</span><span class="sc2">3</span><span class="sc0">          </span><span class="sc1">; start operation of channes 0&amp;1</span><span class="sc0">
    </span><span class="sc5">clr1</span><span class="sc0">    </span><span class="sc5">MK0H.1</span><span class="sc0">              </span><span class="sc1">; enable receiver interrupt INTSR0</span><span class="sc0">
    </span><span class="sc6">ret</span><span class="sc0">
</span><span class="sc1">;------------------------STORAGE I2C SETUP ROUTINES--------------------------</span><span class="sc0">
</span><span class="sc5">init_FRAM_Write</span><span class="sc4">:</span><span class="sc0">
    </span><span class="sc6">bt</span><span class="sc0">      </span><span class="sc5">IICS0.6</span><span class="sc4">,</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc4">-</span><span class="sc2">0</span><span class="sc0">        </span><span class="sc1">; wait for i2c ready</span><span class="sc0">
    </span><span class="sc5">set1</span><span class="sc0">    </span><span class="sc5">IICCTL00.1</span><span class="sc0">          </span><span class="sc1">; generate start</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">IICA0</span><span class="sc4">,</span><span class="sc0">  #</span><span class="sc2">0xA0</span><span class="sc0">       </span><span class="sc1">; send slave address AND r/w bit(last bit)</span><span class="sc0">
    </span><span class="sc5">halt</span><span class="sc0">                        </span><span class="sc1">; r = 1   w = 0</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">IICA0</span><span class="sc4">,</span><span class="sc0">  #</span><span class="sc2">0x00</span><span class="sc0">       </span><span class="sc1">; send MSB memory start location</span><span class="sc0">
    </span><span class="sc5">halt</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">IICA0</span><span class="sc4">,</span><span class="sc0">  #</span><span class="sc2">0x00</span><span class="sc0">       </span><span class="sc1">; send LSB memory start location</span><span class="sc0">
    </span><span class="sc5">halt</span><span class="sc0">
    </span><span class="sc6">ret</span><span class="sc0">                         </span><span class="sc1">; done setting up, continue to UART</span><span class="sc0">
</pre><div class="caption">These two procedures initialize the UART communication within the microcontroller and sets up the device for storing the data into memory.</div>
            </div>
        <div class="smallSpace"></div>
            <div class="codeBoxN">
                <pre>
                
</span><span class="sc5">get_UART</span><span class="sc4">:</span><span class="sc0">
    </span><span class="sc5">halt</span><span class="sc0">                        </span><span class="sc1">; wait for char</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">A</span><span class="sc4">,</span><span class="sc0">      </span><span class="sc5">RXD0</span><span class="sc0">        </span><span class="sc1">; read char</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">IICA0</span><span class="sc4">,</span><span class="sc0">  </span><span class="sc5">A</span><span class="sc0">           </span><span class="sc1">; send the char to FRAM</span><span class="sc0">
    </span><span class="sc5">halt</span><span class="sc0">
    </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc5">A</span><span class="sc4">,</span><span class="sc0">      #</span><span class="sc5">term</span><span class="sc0">       </span><span class="sc1">; did we get ESC character?</span><span class="sc0">
    </span><span class="sc5">bnz</span><span class="sc0">     </span><span class="sc5">get_UART</span><span class="sc0">            </span><span class="sc1">; NO - loop back    </span><span class="sc0">
            
    </span><span class="sc5">set1</span><span class="sc0">    </span><span class="sc5">IICCTL00.0</span><span class="sc0">          </span><span class="sc1">; STOP signal for I2C   </span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">ST0L</span><span class="sc4">,</span><span class="sc0">   #</span><span class="sc2">0x03</span><span class="sc0">       </span><span class="sc1">; STOP UART recieve</span><span class="sc0">
    </span><span class="sc5">clr1</span><span class="sc0">    </span><span class="sc5">PER0.2</span><span class="sc0">              </span><span class="sc1">; STOP UART clock</span><span class="sc0">
    </span><span class="sc5">set1</span><span class="sc0">    </span><span class="sc5">MK0H.1</span><span class="sc0">              </span><span class="sc1">; STOP UART interrupts</span><span class="sc0">
    </span><span class="sc5">movw</span><span class="sc0">    </span><span class="sc8">AX</span><span class="sc4">,</span><span class="sc0">     #</span><span class="sc2">20</span><span class="sc0">         </span><span class="sc1">; short delay</span><span class="sc0">
    </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">delay</span><span class="sc0">
    </span><span class="sc6">ret</span><span class="sc0">
</pre><div class="caption">This is the procedure that reads the data from the USB to UART bridge and stores the data into memory.</div>
            </div>
        <p>During a display cycle, the unit reads characters from memory placing these into a 16 character array. Two seperate arrays are used, one array per display line. Once an 
            array is filled it is send to the display via I2C communication. If the unit reads less than 16 characters during an array fill, the unit will fill the remaining positions with a 'space' 
            character. This process is then repeated. </p>
            <div class="codeBoxN">
                <pre>
                
</span><span class="sc1">;-----------------------------FILL ARRAY ROUTINE-----------------------</span><span class="sc0">
</span><span class="sc5">fillArray</span><span class="sc4">:</span><span class="sc0">
    </span><span class="sc5">movw</span><span class="sc0">    </span><span class="sc8">AX</span><span class="sc4">,</span><span class="sc0">     </span><span class="sc5">HL</span><span class="sc0">          </span><span class="sc1">; start address</span><span class="sc0">
    </span><span class="sc5">addw</span><span class="sc0">    </span><span class="sc8">AX</span><span class="sc4">,</span><span class="sc0">     #</span><span class="sc2">16</span><span class="sc0">
    </span><span class="sc5">movw</span><span class="sc0">    </span><span class="sc5">DE</span><span class="sc4">,</span><span class="sc0">     </span><span class="sc8">AX</span><span class="sc0">          </span><span class="sc1">; end address</span><span class="sc0">
</span><span class="sc5">fa1</span><span class="sc4">:</span><span class="sc0">    
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">A</span><span class="sc4">,</span><span class="sc0">      </span><span class="sc5">ready</span><span class="sc0">       </span><span class="sc1">; check the ready flag</span><span class="sc0">
    </span><span class="sc5">cmp0</span><span class="sc0">    </span><span class="sc5">A</span><span class="sc0">                   </span><span class="sc1">; if 1, we are done</span><span class="sc0">
    </span><span class="sc5">bnz</span><span class="sc0">     </span><span class="sc5">fa2</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">A</span><span class="sc4">,</span><span class="sc0">      #</span><span class="sc2">10</span><span class="sc0">         </span><span class="sc1">; 10 usec delay needed by I2C</span><span class="sc0">
    </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc5">A</span><span class="sc0">                   </span><span class="sc1">; between STOP and START</span><span class="sc0">
    </span><span class="sc5">bnz</span><span class="sc0">     </span><span class="sc10">$</span><span class="sc4">-</span><span class="sc2">1</span><span class="sc0">
    </span><span class="sc6">bt</span><span class="sc0">      </span><span class="sc5">IICS0.6</span><span class="sc4">,</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc4">-</span><span class="sc2">0</span><span class="sc0">
    </span><span class="sc5">set1</span><span class="sc0">    </span><span class="sc5">IICCTL00.1</span><span class="sc0">          </span><span class="sc1">; generate START signal</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">IICA0</span><span class="sc4">,</span><span class="sc0">  #</span><span class="sc2">0xA1</span><span class="sc0">       </span><span class="sc1">; send slave address with r/w = 1</span><span class="sc0">
    </span><span class="sc5">halt</span><span class="sc0">                        </span><span class="sc1">; wait for ACK</span><span class="sc0">
    </span><span class="sc5">clr1</span><span class="sc0">    </span><span class="sc5">IICCTL00.2</span><span class="sc0">          </span><span class="sc1">; setup for NACK</span><span class="sc0">
    </span><span class="sc5">set1</span><span class="sc0">    </span><span class="sc5">IICCTL00.5</span><span class="sc0">          </span><span class="sc1">; request next char form FRAM</span><span class="sc0">
    </span><span class="sc5">halt</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">A</span><span class="sc4">,</span><span class="sc0">      </span><span class="sc5">IICA0</span><span class="sc0">       </span><span class="sc1">; get character</span><span class="sc0">
    </span><span class="sc5">set1</span><span class="sc0">    </span><span class="sc5">IICCTL00.0</span><span class="sc0">          </span><span class="sc1">; generate STOP signal</span><span class="sc0">
    </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc5">A</span><span class="sc4">,</span><span class="sc0">      #</span><span class="sc5">term</span><span class="sc0">       </span><span class="sc1">; check for ESC</span><span class="sc0">
    </span><span class="sc5">bnz</span><span class="sc0">     </span><span class="sc5">fa3</span><span class="sc0">                 </span><span class="sc1">; we are done</span><span class="sc0">
</span><span class="sc5">fa2</span><span class="sc4">:</span><span class="sc0">    
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">ready</span><span class="sc4">,</span><span class="sc0">  #</span><span class="sc2">1</span><span class="sc0">          </span><span class="sc1">; end of string flag</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">A</span><span class="sc4">,</span><span class="sc0">      #</span><span class="sc2">0x20</span><span class="sc0">       </span><span class="sc1">; a = 'space' character</span><span class="sc0">
</span><span class="sc5">fa3</span><span class="sc4">:</span><span class="sc0">    
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">HL</span><span class="sc4">],</span><span class="sc0">   </span><span class="sc5">A</span><span class="sc0">           </span><span class="sc1">; array1[i] = a (input[i])</span><span class="sc0">
    </span><span class="sc5">incw</span><span class="sc0">    </span><span class="sc5">HL</span><span class="sc0">                  </span><span class="sc1">; inc array pointer</span><span class="sc0">
    </span><span class="sc5">movw</span><span class="sc0">    </span><span class="sc8">AX</span><span class="sc4">,</span><span class="sc0">     </span><span class="sc5">HL</span><span class="sc0">          </span><span class="sc1">;</span><span class="sc0">
    </span><span class="sc5">cmpw</span><span class="sc0">    </span><span class="sc8">AX</span><span class="sc4">,</span><span class="sc0">     </span><span class="sc5">DE</span><span class="sc0">          </span><span class="sc1">; did we hit 16 chars?</span><span class="sc0">
    </span><span class="sc5">bnz</span><span class="sc0">     </span><span class="sc5">fa1</span><span class="sc0">                 </span><span class="sc1">; no - loop back</span><span class="sc0">
    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc5">A</span><span class="sc4">,</span><span class="sc0">      #</span><span class="sc2">20</span><span class="sc0">         </span><span class="sc1">; 10 usec delay needed by I2C</span><span class="sc0">
    </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc5">A</span><span class="sc0">                   </span><span class="sc1">; between STOP and START</span><span class="sc0">
    </span><span class="sc5">bnz</span><span class="sc0">     </span><span class="sc10">$</span><span class="sc4">-</span><span class="sc2">1</span><span class="sc0"> 
    </span><span class="sc6">ret</span><span class="sc0">                         </span><span class="sc1">; ret to caller</span><span class="sc0">
</pre><div class="caption">This is the procedure used to fill the two arrays that will be sent to the LCD display.</div>
            </div>



            <h2>Please Check Back for Updates!</h2>
            <p style="text-align:center;">
			<a href="https://raw.githubusercontent.com/dusanders/dusanders.github.io/master/ASM/Source/scroll.s87" target="_blank">Download Source File</a>
            </p>
			<p style="text-align:center;">
            <a href="https://github.com/dusanders/dusanders.github.io/tree/master/ASM/Source/" target="_blank">View Source Files Folder</a>
            </p>
            <div id="footer">
                <div id="copyright">
                    <p>Copyright &copy; 2015 Dustin Anderson</p>
                </div>
                <div id="aboutButton">
                    <p><a href="../index.html">About</a></p>
                </div>
            </div>
        </div><!--End content-div-->
        <div id="sideBar">
            <ul id="sideBarList">
                <p style="text-align:center; text-decoration:underline;">Projects</p>
                <li class="sideBarItem" id="ScrollProject" style="color: #006600; cursor:default;">Scroll Project</li>
                <li class="sideBarItem" id="BluetoothRc"><a href="ASMBTLE.html">BTLE RC Car</a></li>
            </ul>
        </div>
        <div id="menuBar">
            <ul id="menuList">
                <li class="menuItem"><a href="../CPP/CPP.html">C++</a></li>
                <li class="menuItem"><a href="../CSHARP/CSharp.html">C#</a></li>
                <li class="menuItem"><a href="../JAVA/Java.html">Java</a></li>
                <li class="menuItem" style="color: #80CC80;">Embedded Systems</li>
                <li class="menuItem" ><a href="../ANDROID/AndroidHome.html">Android</a></li>
            </ul>
        </div>
    </div><!--end container-->
</body>
</html>
