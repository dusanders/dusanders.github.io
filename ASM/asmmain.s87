;	Author:		Dustin Anderson
;	Title:		Scroll
;	Problems:
;
;	Description:	This program is intended to take an input string and split
;			this string into two display lines (16x2). The program then
;			should 'scroll' the display if the input string is longer
;			32. This is done by copying the bottom display line to the
;			top display line and pulling a newly formed bottom line
;			from the input string.

#include "ior5f1026a.h"
#include "ior5f1026a_ext.h"

#define  STIF0      IF0H.0
#define  SRIF0      IF0H.1
#define  SREIF0     IF0H.2
#define  SAU0EN     PER0.2  			; serial array unit 0 enable
#define  STMK0      MK0H.0  			; error flag locations
#define  SRMK0      MK0H.1
#define  SREMK0     MK0H.2
#define  BFF01      SSR01.5

#define	RST	P1.3						; LCD reset pin
#define	term	0x24					; string terminal char ($)

    RSEG    CSTACK          			; stack segment definition
	RSEG	NEAR_N						; DATA segment
array1:		DS	16						; 16 bytes for upper  LCD
array2: 	DS	16						; 16 bytes for bottom LCD
ptr:    	DS      2       			; pointer
cnt:		DS	1						; scroll speed counter
ready:		DS	1						; EOT flag

buff_len        EQU     16              ; buffer size
uartData:       DS      buff_len        ; data receive buffer
dataPtr:        DS      2               ; data buffer pointer
sendPtr:        DS      2		;
buff_cnt:       DS      1   	; flag for first mem access
SPEED:		DS	1				; scrolling speed

    ASEGN   RCODE:CODE, 0   	; vector table
    ORG     RST_vect
    DW      RESET           	; Reset vector
	ORG		INTIICA0_vect
	DW		I2C_ISR				; I2C vector
	ORG		INTIT_vect
	DW		INTIT_ISR			; 12-bit interval timer vector
	ORG     INTST0_vect
    DW      INTST0_ISR			; UART transmit vector
	ORG     INTSR0_vect
    DW      INTSR0_ISR			; UART receive vector

	ORG	0xC0					; option byte
	DB	0x6E					; disable watchdog
	DB	0x1F					; 1.67V/1.63V LVD off
	DB	0xAA					; 8 MHz LS mode
	DB	0x85					; enable on-chip debugging

        RSEG    CODE            ; code segment
RESET: 	movw	SP,	#SFE(CSTACK); setting up the stack pointer

  	; clock setup
	mov	HOCODIV, 	#0x02		; set 8 MHz system clock
	mov	PER0,		#0x90		; enable RTC, I2C operation
	mov	OSMC, 		#0x90		; select LFO as s/system clock

	clrw	AX					; power-up delay for 65 msec
pw_up:	
	br		$+2					; to debounce the button			
	subw	AX,		#1			; 1 usec delay for CPU
	bnz		pw_up				; clocked at 8 MHz	

	; ports setup
	mov		ADPC, 	#0x01		; set digital mode on all pins
	mov		PM1,  	#0xF2		; configure port for input (p11, p12)
	mov		PMC1,	#0xE0		; set digital mode for P1
	mov		PM2,  	#0xF0		; configure port for output
	mov		PM4,	#0xF9		; configure port for output
	mov		PMC4,	#0xF9		; set digital mode for P4

	mov		P1,		#0x04		; init port outputs
	mov		P2,		#0x00
	mov		P4,		#0x00

	; I2C setup
	mov		IICWL0,	#31			; setup for 120 KHz operation @ 8 MHz
	mov		IICWH0,	#34
	mov		SVA0,	#0x7C		; own slave address
    mov		IICF0,	#3			; enable START w/out STOP, no reservation
	mov		IICCTL00, #0x0C
	clr1	MK0H.5				; enable I2C interrupts
	set1	IICCTL00.7			; enable I2C operation
	set1	IICCTL00.6			; cancel current operation
	mov		PM6,	#0xFC		; configure port pins for output
	mov		P6, 	#0x00		; init I2C pins

	EI							; enable interrupts globally
	call	Init_System			; configure LCD display and memory

	mov1	CY,	P1.1			; USB connected?
	sknc	
	 call	get_USB				; YES - get string from USB 
	call	init_FRAM_Read		; setup for reading from memory
	
	; Interval timer setup
	movw	ITMC,	#0x8FFF		; set 270 msec period, int. enable
	clr1	MK1L.3				; enable 12-bit timer interrupt
	
	br	entry
;----------------------------MAIN PROGRAM LOOP--------------------------
loop:
	stop						; put MCU on sleep
	nop							; wake-up by 12-bit timer
	dec		cnt					; wait for next scroll
	bnz		loop
	mov		A,		SPEED
	mov		cnt,	A			; update the counter

entry:	
	call	copyArray			; array2 -> array1

	movw	HL,		#array2		; HL = array2 (bottom display line)
	call	fillArray			; fill array2

	movw	HL,		#array1		; HL = address of array1 buffer
	mov		A,		#0x80		; RAM address of line 1
	call	sendString			; send array1
	movw	HL,		#array2		; HL = address of array2 buffer
	mov		A,		#0xC0		; RAM address of line 2
	call	sendString			; send array2

	mov		A,	ready			; is all string displayed?
	cmp0	A
	bz		loop				; skip if YES

	mov		ptr,	#0			; start over
	mov		ptr+1,	#0
	mov		ready,	#0
	call	init_FRAM_Read		; restart memory location
	br	loop

;----------------------------------------------------------------
test_FRAM:
 	; FRAM write
	movw	BC,		#0			; pointer to test string
	call	init_FRAM_Write		; setup storage I2C for UART recp.
L1:	mov		ES,		#0
	mov		A,		ES:test[BC]	; get char from flash
	mov		ES,		#0x0F	
	incw	BC					; update string pointer
    mov		IICA0,	A			; send the char to FRAM
	halt						; wait for ACK
	cmp		A,		#term		; did we get ESC character?
	bnz		L1					; NO - loop back		        
	set1    IICCTL00.0      	; STOP signal for I2C
	movw	AX,		#20			; short delay
	call	delay
	; FRAM read
L2:	movw	HL,		#array1		; read here from FRAM
	call	init_FRAM_Read
	set1	IICCTL00.1			; generate START condition
	set1	IICCTL00.2			; setup for ACK
	mov		IICA0,	#0xA1		; send I2C address + read
	halt						; wait for the end of transfer	
L3:	set1	IICCTL00.5			; start I2C receive
	halt						; wait for the end of receive
	mov		A,		IICA0		; get received byte
	cmp		A,		#term		; did we get ESC character?
	bz		L4					; YES - end	
	mov		[HL],	A			; NO  - copy char to buffer	
	incw	HL					; update buffer pointer
	br		L3					; loop back		        
L4:	clr1	IICCTL00.2			; setup for NACK
	set1	IICCTL00.5			; start receive
	halt						; wait for the end of receive
	set1    IICCTL00.0      	; STOP signal for I2C
	movw	AX,		#20			; short delay	
	call	delay
	
lll:	br lll	

;----------------------------------------------------------------
get_USB:						; load string from USB to FRAM
    call	init_UART       	; NO - init_UART and begin reading
	call	init_FRAM_Write		; setup storage I2C for UART recp.

get_UART:
	halt						; wait for char
	mov		A,		RXD0        ; read char
    mov		IICA0,	A			; send the char to FRAM
	halt
	cmp		A,		#term		; did we get ESC character?
	bnz		get_UART        	; NO - loop back	
	        
	set1    IICCTL00.0      	; STOP signal for I2C	
    mov     ST0L,	#0x03   	; STOP UART recieve
    clr1    PER0.2          	; STOP UART clock
    set1    MK0H.1          	; STOP UART interrupts
	movw	AX,		#20			; short delay
	call	delay
	ret

;==============UART SETUP======================================
init_UART:
    set1    PER0.2 				; enable clock for SAU0
    mov		SPS0L,	#0x22 		; set 2 MHz SAU0 clock
	movw	AX,		#0x0022		; set UART mode, CKS00 clock
	movw	SMR00,	AX		
	movw	AX,		#0x8197
	movw	SCR00,	AX			; enable TX, 8N1, 8-bit data  
	movw	AX,		#0xCE00		; setup for 9600 baud
	movw	SDR00,	AX
	
	movw	AX,		#0x8122		; set UART mode, CKS01 clock
	movw	SMR01,	AX
	movw	AX,		#0x6197
	movw	SCR01,	AX			; enable RX, 8N1, 8-bit data 
	movw	AX,		#0xCE00		; setup for 9600 baud
	movw	SDR01,	AX
	
	movw	AX,		#0x401		; set output =1
	movw	SO0,	AX
	mov		SOE0L,	#1			; enable serial output	
	mov		SSC0,	#2			; enable receive interrupt
	mov		SS0L,	#3			; start operation of channes 0&1
	clr1	MK0H.1				; enable receiver interrupt INTSR0
	ret

;-----------------------------COPY ARRAY ROUTINE-----------------------
copyArray:						; copy array2 -> array1
	movw	DE,		#array1		; DE = array1
	movw	HL,		#array2		; HL = array2
cal:
	mov		A,		[HL]		; a = array2[i]
	mov		[DE],	A			; array1[i] = a
	incw	DE					; inc ptr
	incw	HL
	movw	AX,		HL
	cmpw	AX,		#array2+16	; 16 char?
	bnz		cal					; NO - loop back
	ret							; return to caller

;-----------------------------FILL ARRAY ROUTINE-----------------------
fillArray:
	movw	AX,		HL			; start address
	addw	AX,		#16
	movw	DE,		AX			; end address

fa1:	
	mov		A,		ready		; check the ready flag
	cmp0	A					; if 1, we are done
	bnz		fa2

	mov		A, 		#10			; 10 usec delay needed by I2C
	dec		A					; between STOP and START
	bnz		$-1
	bt		IICS0.6, $-0
	set1	IICCTL00.1			; generate START signal
	mov		IICA0,	#0xA1		; send slave address with r/w = 1
	halt                    	; wait for ACK
	clr1	IICCTL00.2			; setup for NACK
	set1	IICCTL00.5			; request next char form FRAM
	halt
	mov		A,		IICA0		; get character
	set1    IICCTL00.0      	; generate STOP signal

	cmp		A,		#term		; check for ESC
	bnz		fa3					; we are done
fa2:	
	mov		ready,	#1			; end of string flag
	mov		A,		#0x20		; a = 'space' character
fa3:	
	mov		[HL], 	A			; array1[i] = a (input[i])
	incw	HL					; inc array pointer
	movw	AX,		HL			;
	cmpw	AX, 	DE			; did we hit 16 chars?
	bnz		fa1					; no - loop back
	mov		A, 		#20			; 10 usec delay needed by I2C
	dec		A					; between STOP and START
	bnz		$-1	
	ret							; ret to caller

;------------------------STORAGE I2C SETUP ROUTINES--------------------------
init_FRAM_Write:
	bt		IICS0.6, $-0		; wait for i2c ready
	set1	IICCTL00.1			; generate start
	mov		IICA0,	#0xA0		; send slave address AND r/w bit(last bit)
	halt						; r = 1   w = 0
	mov		IICA0,	#0x00		; send MSB memory start location
	halt
	mov		IICA0,	#0x00		; send LSB memory start location
	halt
	ret							; done setting up, continue to UART

init_FRAM_Read:
	bt		IICS0.6, $-0		; wait for i2c ready
	set1	IICCTL00.1			; generate START condition
	set1	IICCTL00.2			; setup for ACK
	mov		IICA0,	#0xA0		; send I2C address + write
	halt						; wait for the end of transfer
	mov		IICA0,	#0x00		; send address MSB
	halt		
	mov		IICA0,	#0x00		; send address LSB
	halt
	set1	IICCTL00.0			; generate STOP condition
		
	mov		A, 		#20			; 10 usec delay needed by I2C
	dec		A					; between STOP and START
	bnz		$-1
	
	bt		IICS0.6, $-0
	set1	IICCTL00.1			; generate START signal
	mov		IICA0,	#0xA1		; send slave address with r/w = 1
	halt                    	; wait for ACK
	clr1	IICCTL00.2			; setup for NACK
	set1	IICCTL00.5			; request next char form FRAM
	halt
	mov		A,	IICA0			; get speed
    sub     A,		#0x30   	; sub 48d from ascii code
    mov     SPEED,  A       	; set the speed	
	set1    IICCTL00.0      	; generate STOP signal
	
	mov		A, 		#20			; 10 usec delay needed by I2C
	dec		A					; between STOP and START
	bnz		$-1	
	ret	
	
;------------------------------I2C---Send Routine---(FOR LCD DISPLAY)---
sendString:
    bt      IICS0.6, $-0		; wait for i2c ready
    set1    IICCTL00.1      	; generate Start
	set1	IICCTL00.2			; setup for ACK
    mov     IICA0,	#0x7C   	; LCD slave address
    halt
    mov     IICA0,	#0x80   	; 'CMD follows' signal
    halt
    mov     IICA0,	A       	; set cursor position
    halt
    call    delay50us
    mov     IICA0,	#0x40   	; 'only data follow' signal
    halt
    clrb    B              		; zero string pointer
sendChar:
    mov     A,		[HL+B]      ; a = array[i]
    mov     IICA0,  A
    halt
	call    delay50us			; processing delay
	inc     B					; update counter
	mov		A,		B
	cmp		A,		#16			; 16-char?
    bnz		sendChar

sendStop:
	set1    IICCTL00.0      	; STOP signal
	movw    AX, 	#10     	; short delay
	call    delay
	ret                     	; ret from routine

;--------------------------DELAY ROUTINE-------------------------------
delay50us:						; delay for 50 usec
	movw	AX,		#50
delay:	
	br		$+2					; delay for AX usec
	subw	AX,		#1			; 1 usec delay for CPU
	bnz		delay				; clocked at 8 MHz
	ret

;------------------------------CONFIGURE SYSTEM------------------------
Init_System:
	call	Init_LCD			;configure LCD display
	
	mov		ready,	#0x00		; end of text flag
	mov		ptr,	#0x00		; index of processing string character
	mov		ptr+1,	#0x00		; ptr = 0
	mov		cnt,	#SPEED		; set scroll speed in 270 ms units

	movw	HL, 	#array2		; HL = array2
is1:	
	mov		[HL],	#0x20		; fill bottom line with spaces
	incw	HL					; inc pointer
	movw	AX,		HL
	cmpw	AX,		#array2+16	; 16 char?
	bnz		is1					; loop back
	ret

;------------------------------CONFIGURE LCD DISPLAY-------------------
Init_LCD:						; init sequence for LCD
	set1	RST
	movw	AX,	#50000			; 50 msec power-up delay
	call	delay

il0:	
	bt		IICS0.6, il0		; wait for I2C interface ready
	set1	IICCTL00.1			; generate START condition
	mov		IICA0,	#0x7C		; send RTC address + write
	halt						; wait for the end of transfer
	mov		IICA0,	#0x00		; send last control byte
	halt						; only CMD follow from here
	mov		IICA0,	#0x38		; set 8-bit 2-lines 5x7 mode
	halt
	call	delay50us
	mov		IICA0,	#0x39		; set IS1 instruction table
	halt
	call	delay50us
	mov		IICA0,	#0x14		; set 1/5 bias, 183Hz frame freq
	halt
	call	delay50us
	mov		IICA0,	#0x78		; contrast set
	halt
	call	delay50us
	mov		IICA0,	#0x5E		; power/con/contrast control
	halt
	call	delay50us
	mov		IICA0,	#0x6C		; follower control
	halt
	movw	AX,		#60000		; long delay is required here
	call	delay
	movw	AX,		#60000
	call	delay
	movw	AX,		#60000
	call	delay
	movw	AX,		#60000
	call	delay
	mov		IICA0,	#0x0C		; display on
	halt
	call	delay50us
	mov		IICA0,	#0x01		; clear display
	halt
	movw	AX,		#3000		; longer delay is required
	call	delay
	mov		IICA0,	#0x06		; entry mode set
	halt
	call	delay50us
	set1	IICCTL00.0			; generate STOP condition
	movw	AX,	#10				; short delay
	call	delay
	ret

	; ISR definitions
;===============================================================
I2C_ISR:						; I2C_ISR:
	reti						; just wake-up CPU from sleep

;---------------------------------------------------------------
INTIT_ISR:						; 12-bit interval timer ISR
	reti						; just wake-up CPU from sleep

;---------------------------------------------------------------
INTST0_ISR:
        reti

;---------------------------------------------------------------
INTSR0_ISR:						; UART receive ISR
        clr1    SRIF0  			; clear receive  flag
        reti

	END